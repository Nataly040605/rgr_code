Документация
def num_fun(): #задаем количество функций/аргументов с нужными нам условиями
    n = input()
    try:
        int(n)
        if int(n) > 0:
            return n
        else:
            print("Нужно ввести натуральное число ", end='')
            print()
            return num_fun()
    except ValueError:
        print("Нужно ввести натуральное число ", end='')
        print()
        return num_fun()
Данной функцией мы задаем переменную, которую мы будем использовать при вводе количества функций и аргументов. С помощью try мы делаем «защиту от дурака»: чтоб было введено натуральное число. При вводе чего-то другого (отрицательных значений, нецелых значений, букв) будет выдаваться ошибка и функция предложит ввести то же значение заново, только теперь правильное

def value_vect(): #задаем значения векторов с нужными нам условиями
    n = input()
    try:
        int(n)
        if int(n) == 0 or int(n) == 1:
            return n
        else:
            print("Введите 0 или 1", end='')
            print()
            return value_vect()
    except ValueError:
        print("Введите 0 или 1", end='')
        print()
        return value_vect()
Данной функцией мы задаем переменную, которую мы будем использовать при вводе значений векторов (0 или 1). С помощью try мы делаем «защиту от дурака»: чтоб были введены именно 0 или 1. При вводе чего-то другого (отрицательных значений, нецелых значений, букв) будет выдаваться ошибка и функция предложит ввести то же значение заново, только теперь правильное

def T0(vec): #функция для класса Т0
    if vec[0] == 0:
        return 1
    else:
        return 0
Функция для класса Т0: проверяется, является ли первый элемент в массиве значений булевой функции 0 или 1. 

def T1(vec): #функция для класса Т1
    if vec[-1] == 1:
        return 1
    else:
        return 0
Функция для класса Т1: проверяется, является ли последний элемент в массиве значений булевой функции 0 или 1. 

def S(vec): #функция для класса S
    for i in range(int(float(len(vec)) / 2)):
        if (vec[i] == 1 and vec[len(vec) - 1 - i] == 0) or (vec[i] == 0 and vec[len(vec) - 1 - i] == 1):
            if vec.count(0) == vec.count(1):
                return 1
    return 0
Функция для класса S: для проверки нам нужно разделить функцию напополам (это всегда возможно, так как количество значений БФ - четное). После чего мы сравниваем каждый n-ый элемент массива с его «зеркальным» отражением (я имею ввиду, что мы рассматриваем элемент с таким же номером, но с конца)

def M(vec): #функция для класса М
    another_vec = vec.copy()
    another_vec.sort()
    if vec == another_vec:
        return 1
    return 0
Функция для класса М: для проверки мы берем наш массив значений, делаем его копию, потом смотрим, можно ли упорядочить значения в данной копии. Если да, то функция не монотонна, если нет (то есть исходный массив совпал с копией после упорядочивания), то монотонна

def L(vec, mas, num): #функция для класса L
    x = []
    eyeFun = mas[num]
    vec1 = vec
    for i in range(len(vec) - 1):
        y = []
        for j in range(len(vec) - 1 - i):
            y.append((vec1[j] + vec1[j + 1]) % 2)
        x.append(y)
        vec1 = y
    for i in range(len(x)):
        if x[i][0] == 1:
            a = 0
            for j in range(len(eyeFun)):
                if eyeFun[j][i + 1] == 1:
                    a += 1
            if a > 1:
                return 0
    return 1
Функция для класса L: здесь для проверки нужно провернуть полином Жегалкина. Мы будем сокращать количество значений, поэтому нужно создать циклы с несколькими массивами, чтобы вносить туда полученное. Переменная а здесь – это «счетчик» значений функции, по которым в полиноме Жегалкина мы определяем наличие конъюнкции в строчках. Для строчек где у нас (00, 01, 10 или еще что-либо где 1 переменная) а = 0 по умолчанию ( т.к. конъюнкции там не образуется). Но как только появляется функция=1, где несколько переменных «счетчик» а начинает увеличиваться и в итоге функция L определяет линейна БФ или нет.

def Class(vec, a, clas):
    print(f"БФ №{vec} ", end='')
    if a == 0:
        print('не ', end='')
    print(f'принадлежит {clas}')
Функция Class нужна для определения принадлежности/ не принадлежности функции к разным классам (туда запихиваются return-ы других функций)

print("Введите количество БФ: ", end='')
vectors=[]
funnies=[]
func = int(num_fun())
for num_func in range(1, int(func) + 1):
    print(f"Введите количество аргументов у {num_func} БФ: ", end='')
    arg = int(num_fun())
    step = 2 ** arg  # строки функции
    print("Заполните значения (они должны быть равны 1 или 0):")
    fun = [] * arg
    for i in range(arg):  # заполнение массива
        x = 2 ** i
        a = []
        step_dl = 0
        while (step_dl != step):
            for i in range(x):
                a.append(0)
                step_dl += 1
            for i in range(x):
                a.append(1)
                step_dl += 1
        fun.append(a)
    funnies.append(fun)
    values_mas = []
Здесь у нас собственно самый начальный запрос «задания» БФ, а также создание массива с нужным количеством «переменных» (ну то есть мы ж вводим количество аргументов функции и теперь должны создать массив в нужным количеством «мест», равным 2^(количество аргументов))

    for i in range(step):  # значения бф
        for j in range(arg):
            print(fun[arg - 1 - j][i], end='')
        print(":", end='')
        vec = int(value_vect())
        values_mas.append(vec)
    vectors.append(values_mas)
    print(values_mas)
Здесь мы собственно заполняем наш массив значениями БФ ( то есть 1 или 0) и + тут вывод на экран «номеров» элементов массива, типа 00:, 01: и тд.

post = []
for vec in range(func): #определяется принадлежность к классам
    s_p = []
    s_p.append(T0(vectors[vec]))
    Class(vec + 1, s_p[0], "классу T0")
    s_p.append(T1(vectors[vec]))
    Class(vec + 1, s_p[1], "классу T1")
    s_p.append(M(vectors[vec]))
    Class(vec + 1, s_p[2], "классу монотоности")
    s_p.append(S(vectors[vec]))
    Class(vec + 1, s_p[3], "классу самодвойственности")
    s_p.append(L(vectors[vec], funnies, vec))
    Class(vec + 1, s_p[4], "классу линейности")
    post.append(s_p)
Здесь мы создаем общий массив откуда программа узнает, сколько было введено функций и к каким классам они принадлежат

ne_post = 1
if len(post) == 1:
    print("Нельзя построить ПФН из одной функции")
Тут вроде и так пронятно, что если функций всего 1, то функциональный набор не построишь

else:
    for i in range(5):
        s = 0
        for j in range(len(post)):
            if post[j][i] == 1:
                s += 1
        if s == len(post):
            ne_post = 0
    if ne_post == 1:
        print("Данный набор функций - ПФН")
    else:
        print("Данный набор функций - не ПФН")
Здесь программа смотрит сколько функций из 5-ти выполняется для каждой введённой БФ, на основе чего и делается вывод о том ПНФ это или не ПНФ
